(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{529:function(e,t,n){"use strict";n.r(t);var o=n(7),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("blockquote",[n("p",[e._v("函数封装的好处就是简化代码量，便于我们查看和维护；其次就是可以重复调用，避免许多重复的代码；js中的许多方法就是js作者所封装好的函数，我们只要直接调用就可以了。")])]),e._v(" "),n("p",[n("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/912092-b57299ffe98a2345.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"login.jpg"}}),e._v("图中所示就是拖拽的原理;同理可以得出Y轴的移动距离,然后就是在移动时赋值给登陆框。")]),e._v(" "),n("p",[n("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/912092-e45d6c011f9014ed.gif?imageMogr2/auto-orient/strip",alt:"l模拟百度登陆框的效果"}})]),e._v(" "),n("p",[e._v("##拖拽函数的封装")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("function drag(obj, box) { //obj:拖拽的对象;box:移动的对象;  一个参数时拖动自身;\nif (box) {} else {//当第二个参数为空时，调用obj;\n    box = obj;\n};\nvar distanceTop = box.offsetTop - obj.offsetTop;//拖拽对象与移动对象的偏离值;\nvar distanceLeft = box.offsetLeft - obj.offsetLeft;\nobj.onmousedown = function(ev) { //点击登陆窗口顶部，获取偏移值;\n    even(ev);//封装的事件对象函数\n    stopBubble(ev);//封装的取消冒泡函数\n    var disx = ev.offsetX;\n    var disy = ev.offsetY;\n    var l = 0;//登陆框移动的X轴距离\n    var t = 0;//登陆框移动的Y轴距离\n    if (obj.setCapture) {\n        obj.setCapture();\n    }\n    document.onmousemove = function(ev) { //拖拽窗口;\n        var ev = ev || window.event;\n        l = ev.clientX - disx;\n        if (l < 0) {//限定登陆移动的距离，禁止移除窗口;\n            l = 0;\n        } else if (l >= document.documentElement.clientWidth - box.offsetWidth) {\n            l = document.documentElement.clientWidth - box.offsetWidth;\n        }\n        t = ev.clientY - disy;\n        if (t < 0) {//限定登陆移动的距离，禁止移除窗口;\n            t = 0;\n        } else if (t >= document.documentElement.clientHeight - box.offsetHeight) {\n            t = document.documentElement.clientHeight - box.offsetHeight;\n        }\n        box.style.left = l + distanceTop + 'px';\n        box.style.top = t + distanceLeft + 'px';\n    }\n    document.onmouseup = function() { //松开鼠标取消事件;\n        document.onmousemove = null;\n        if (obj.releaseCapture) {\n            obj.releaseCapture();\n        };\n    };\n    return false;\n};\n")])])]),n("p",[n("code",[e._v("drag（oDiv）")]),e._v("直接就可以调用这个函数，移动"),n("code",[e._v("oDiv")]),e._v("这个元素，当然事先得获取这个元素，还有一点你得给这个元素的css样式添加定位,否则无法移动。")]),e._v(" "),n("p",[e._v("这里的"),n("code",[e._v("oDiv")]),e._v("就是‘传参’，传入的参数可与"),n("code",[e._v("function drag(obj, box)")]),e._v("中的'实参'个数不同。1个参数时是移动自身；2个参数时，"),n("code",[e._v("obj:")]),e._v("拖拽的对象;"),n("code",[e._v("box:")]),e._v("移动的对象;")]),e._v(" "),n("p",[e._v("当然，这只是一个简单的封装，并不能保证100%适用；在这个函数封装的过程中，最重要的就是事件流了；")]),e._v(" "),n("p",[e._v("###事件流")]),e._v(" "),n("p",[e._v("事件流描述的就是从页面中接受事件的顺序；")]),e._v(" "),n("p",[e._v("如果你单击了某个按钮，单击事件并不仅仅发生在这个按钮上，相当于你同时也单击了按钮的容器元素，甚至单击了整个页面。")]),e._v(" "),n("p",[n("em",[e._v("但有意思的时，在遇到这个问题时，IE团队和网景团队提出了完全相反的事件流概念。IE提出的是事件冒泡流，即事件从子元素传递到父元素上；而网景团队提出的是事件捕获流，事件从父元素传递到子元素上；")])]),e._v(" "),n("p",[e._v("w3c就在这个前提下，取了折中的办法，规定事件先经过捕获阶段，然后是目标阶段，再到冒泡。")]),e._v(" "),n("p",[e._v("既然有冒泡，也就有取消冒泡，避免事件冲突；")]),e._v(" "),n("p",[e._v("就像图中的登陆框一样，你点击了其中的输入框，相当于同时也点击登录框，如果事先并未处理，造成的结果就是无法让输入框获取光标。")])])}),[],!1,null,null,null);t.default=i.exports}}]);